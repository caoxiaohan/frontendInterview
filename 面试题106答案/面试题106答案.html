<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>面试题106答案</title>
</head>
<body>
<h1>106 什么是事件，列举出常用的事件及其功能说明？如何获取事件对象e，事件对象的常用属性及方法？事件对象的浏览器兼容问题及处理？事件有哪几个传播阶段？举例说明事件传播机制？事件委托的作用是什么？举例说明事件委托的原理？写一个鼠标跟随效果？</h1>
<input type="text" name="username" id="username" value="cxh"  />  
<pre>
  一、什么是事件，列举出常用的事件及其功能说明？
      1、事件：元素的某一具体行为。
         事件绑定:给元素的某一个行为绑定方法,当行为触发的时候执行对应的方法。
      2、常用事件行为：
          属性    当以下情况发生时，出现此事件
        onabort     图像加载被中断 
        onblur      元素失去焦点
        onchange    用户改变域的内容 
        onclick     鼠标点击某个对象 
        ondblclick  鼠标双击某个对象
        onerror     当加载文档或图像时发生某个错误
        onfocus     元素获得焦点
        onkeydown   某个键盘的键被按下
        onkeypress  某个键盘的键被按下或按住
        onkeyup     某个键盘的键被松开
        onload      某个页面或图像被完成加载
        onmousedown 某个鼠标按键被按下
        onmousemove 鼠标被移动
        onmouseout  鼠标从某元素移开
        onmouseover 鼠标被移到某元素之上
        onmouseup   某个鼠标按键被松开
        onreset     重置按钮被点击
        onresize    窗口或框架被调整尺寸
        onselect    文本被选定
        onsubmit    提交按钮被点击
        onunload    用户退出页面



  二、如何获取事件对象e，事件对象的常用属性及方法？
      1、获取事件对象e：
         1.1、标准浏览器下：e
         1.2、IE浏览器下：window.event
         1.3、事件绑定方法的最后一个参数:arguments[arguments.length-1];
               详见附件《验证事件对象自动传参（最后一个参数）.html》
      2、事件对象的常用属性及方法
         2.1 通用鼠标/键盘属性
            属性              描述
            altKey          返回当事件被触发时，"ALT" 是否被按下。
            button          返回当事件被触发时，哪个鼠标按钮被点击。
            clientX         返回当事件被触发时，鼠标指针的水平坐标。
            clientY         返回当事件被触发时，鼠标指针的垂直坐标。
            ctrlKey         返回当事件被触发时，"CTRL" 键是否被按下。
            metaKey         返回当事件被触发时，"meta" 键是否被按下。
            relatedTarget   返回与事件的目标节点相关的节点。
            screenX         返回当某个事件被触发时，鼠标指针的水平坐标。
            screenY         返回当某个事件被触发时，鼠标指针的垂直坐标。
            shiftKey         返回当事件被触发时，"SHIFT" 键是否被按下
        2.2 标准 Event 属性和方法
            2.2.1 标准 Event 属性
                下面列出了 2 级 DOM 事件标准定义的属性。
                    属性              描述
                    bubbles         返回布尔值，指示事件是否是起泡事件类型。
                    cancelable      返回布尔值，指示事件是否可拥可取消的默认动作。
                    currentTarget   返回其事件监听器触发该事件的元素。
                    eventPhase      返回事件传播的当前阶段。
                    target          返回触发此事件的元素（事件的目标节点）。
                    timeStamp       返回事件生成的日期和时间。
                    type            返回当前 Event 对象表示的事件的名称。
            2.2.2 标准 Event 方法
                下面列出了 2 级 DOM 事件标准定义的方法。IE 的事件模型不支持这些方法：
                    方法                  描述
                    initEvent()         初始化新创建的 Event 对象的属性。
                    preventDefault()    通知浏览器不要执行与事件关联的默认动作。
                    stopPropagation()   不再派发事件。
        2.3 IE 属性
            除了上面的鼠标/事件属性，IE 浏览器还支持下面的属性：
            属性          描述
            cancelBubble    如果事件句柄想阻止事件传播到包容对象，必须把该属性设为 true。
            fromElement     对于 mouseover 和 mouseout 事件，fromElement 引用移出鼠标的元素。
            keyCode         对于 keypress 事件，该属性声明了被敲击的键生成的 Unicode 字符码。对于 keydown 和 keyup    
                            事件，它指定了被敲击的键的虚拟键盘码。虚拟键盘码可能和使用的键盘的布局相关。
            offsetX,offsetY 发生事件的地点在事件源元素的坐标系统中的 x 坐标和 y 坐标。
            returnValue     如果设置了该属性，它的值比事件句柄的返回值优先级高。把这个属性设置为 
                            fasle，可以取消发生事件的源元素的默认动作。
            srcElement      对于生成事件的 Window 对象、Document 对象或 Element 对象的引用。
            toElement       对于 mouseover 和 mouseout 事件，该属性引用移入鼠标的元素。
            x,y             事件发生的位置的 x 坐标和 y 坐标，它们相对于用CSS动态定位的最内层包容元素。
      3、图解事件对象clientX、screenX、pageX、layerX、offsetX、x的区别
         详见附件《图解事件对象clientX、screenX、pageX、offsetX、x、layerX的区别.doc》和《图解事件对象clientX、screenX、pageX、offsetX、x、layerX的区别.html》

       
       
  三、事件对象的浏览器兼容问题及处理？
       [在IE6~8和firefox浏览器中不兼容的属性]
       1、事件对象
          除firefox之外的标准浏览器中：可以自动将事件对象传入最后一个参数，e或arguments[arguments.lenght-1]或window.event均可。
          firefox浏览器中：只能通过e或arguments[arguments.lenght-1]获取事件对象。
          IE8&IE8-浏览器中：只能通过window.event获取事件对象。
          兼容写法：e=e||window.event;
       2、事件源(当前鼠标是在哪个元素上操作的,那么事件源就是谁)
          标准浏览器中：e.target 
          IE8&IE8-浏览器中：e.srcElement
          兼容写法：e.target = e.target || e.srcElement;
       3、e.pageX/Y(鼠标距离HTML页面初始page第一屏原点的距离,包含滚动卷曲的距离)
          标准浏览器中：e.pageX和e.pageY直接获取。
          IE8&IE8-浏览器中:e.clientY + (document.documentElement.scrollTop || document.body.scrollTop)
          兼容写法：e.pageY = e.pageY || (e.clientY + (document.documentElement.scrollTop || document.body.scrollTop));
       4、e.offsetX/Y(鼠标距离事件源左上角的距离，不包含边框)
          非firefox浏览器中：e.offsetX和e.offsetY直接获取。
          firefox浏览器章：e.layerX和e.layer获取。
          兼容写法：e.offsetX=e.offsetX||e.layerX;
       5、阻止事件默认行为
          标准浏览器：e.preventDefault();
          IE8&IE8-浏览器中：e.returnValue=false;
          兼容写法：e.preventDefault ? e.preventDefault() : e.returnValue = false;
       6、阻止事件的冒泡传播
          标准浏览器章：e.stopPropagation();
          IE8&IE8-浏览器中：e.cancelBubble = true;
          兼容写法：e.stopPropagation ? e.stopPropagation() : e.cancelBubble = true;

  四、事件有哪几个传播阶段？
      三个阶段：捕获（从外向内，不包含事件源），目标（当前事件源，捕获和冒泡按代码书写顺序），冒泡（从内向外，不包含事件源）
      第一步输出捕获：html捕获--->body捕获--->outer捕获。（当前元素inner的三个父元素从外向内捕获）
      第二步目标阶段：当前点击的事件源，目标元素为inner。如果inner冒泡代码写在inner捕获前面，则输出顺序为inner冒泡--->inner捕获。 如果inner冒泡代码写在inner捕获后面，则输出顺序为inner捕获--->inner冒泡
      第三步输出冒泡：冒泡outer--->冒泡body--->冒泡html（当前元素inner的三个父元素从内向外冒泡）
      最后输出顺序：第一阶段输出顺序--->第二阶段输出顺序--->第三阶段输出顺序。
      注意：chrome浏览器有个例外，最外层捕获起始于body,html文档不捕获。
  五、举例说明事件传播机制？
      详见《事件传播机制.html》

  六、事件委托的作用是什么？
      1、事件委托概念
        委托（代理）事件是那些被绑定到父级元素的事件，但是只有当满足一定匹配条件时才会被挪。这是靠事件的冒泡机制来实现的。
      2、事件委托/事件代理原理
        主要是利用了事件的冒泡传播机制,假如一个容器中很多元素都需要绑定点击事件,传统的方案是获取到这些元素之后,循环一个个的绑定点击事件,但是现在不用了,我们可以把所有元素的点击事件委托给最外层的这个盒子进行处理。
        不管点击里面的哪个元素,外层盒子的点击行为也会被触发,外层盒子点击行为对应绑定的方法也会被执行,我们此时可以通过传递进来的鼠标事件对象中的事件源来获取到点击的是具体的那个元素,然后在实现相关的操作即可

     3、想要阻止某一个元素的事件委托,我们只需要阻止当前的元素某个行为的冒泡传播即可
        <script type="text/javascript">
            $(function () {
                $(".tabBox").on("click", function (e) {
                    var $tar = $(e.target);
                    //->只有点击的事件源是LI标签我们才会进行选项卡的切换
                    if ($tar[0].tagName.toUpperCase() === "LI") {
                        $tar.addClass("bg").siblings().removeClass("bg");

                        var $index = $tar.index();
                        //$tar.parent().nextAll().eq($index).addClass("bg").siblings().removeClass("bg");
                        $tar.parent().nextAll().each(function (index, item) {
                            index === $index ? $(item).addClass("bg") : $(item).removeClass("bg");
                        });
                    }
                });
                //阻止.tabBox的子元素div的事件委托：
                //$(".tabBox>div").on("click", function (e) {
                //     e.stopPropagation ? e.stopPropagation() : e.cancelBubble = true;
                // });
            });

        </script>
      4、事件委托的作用
        3.1 可以大量节省内存占用减少事件注册，对于ul>li和table>tr>td等子元素的事件需要绑定相同方法的情况尤为合适。
            假设需要给每个Li绑定点击事件onclick绑定方法，通常的做法是循环遍历每个li元素分别给每个li的点击事件绑定方法。
            利用事件委托，只需要给所有li的父元的点击事件绑定一次方法即可。
        3.2 可以实现当新增子对象时无需再次对其绑定事件，对于动态内容部分尤为合适
            假设循环遍历li给每个li的点击事件分别绑定方法，那么如果事后动态添加了新的Li元素，则新元素的点击事件不会绑定方法。
            利用事件委托，新添加的li依然是父元素的子元素，依然可以通过事件冒泡触发父元素上绑定的方法。
     5、事件委托的缺点
        事件代理的应用常用应该仅限于上述需求下，如果把所有事件都用代理就可能会出现事件误判，即本不应用触发事件的被绑上了方法。
        因此使用事件委托时，我们应当首先获取事件源，判断是否是需要绑定方法的元素。
  七、举例说明事件委托的原理？
      详见《事件委托.html》
  八、写一个鼠标跟随效果？
      详见《鼠标跟随.html》和《图解offsetX&offsetY.jpg》
      
     
  


       
</pre>

</body>
</html>